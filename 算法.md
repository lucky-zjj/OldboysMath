# 针对该题的遗传算法框架

基于这篇报告提炼 https://g.co/gemini/share/df2d8a533d21

### 整体类比自然界中优胜劣汰及进化论

对每一代的所有种群进行适应度评估，择优存活作为下一代的父代

1 染色体/个体：潜在的解，本题中应为一个有效的拓扑排序

2 种群：一定规模的个体的合集（比如300个有效拓扑序列）

3 适应度函数：评价个体的优劣量化值，在遗传算法中通常值越大表示适应性越强，第一题求最小值则应考虑取倒数等

4 初始种群（迭代起始前的）：作为第一次迭代前的一定规模的（如300~400个）可能的有效调度序列（通过Kahn算法＋改进算得）

#### 注1：初始种群必须尽量丰富，以避免在单一初始种群下异常收敛陷入局部最优解

（重复执行的）每一代的操作（依次执行）

1 适应度评估：对前代存活的每个调度序列进行适应度函数值的计算，以表征其在本代的存活概率

2 选择：根据每个个体的适应度值，值越大的存活概率越大，选择哪些存活并作为后续操作的父代（锦标赛法，可与轮盘赌等作比较）

3 交叉：因为涉及操作顺序等，传统交叉方法无法保持调度序列的有效性，采用针对调度问题的优先级保持交叉PPX

4 变异（小概率事件）：同3，不能随意变异，选择变异节点后求得其可以“合法”变异的范围比如保持A操作在B前在C后，否则不可变异，重新选择节点

#### 终止条件：固定迭代次数或设定目标适应度值


### 题中提到评估调度算法的性能主要依据两个关键指标：任务的总执行时间和总额外数据搬运量。亦即问题二和三的优化目标。同时需注意问题一三用遗传算法，问题二在问题一基础上按逻辑直接求得换入换出即可

问题一，单一优化目标的改进遗传算法，适应度函数取为1/(1+maxVstay)，此处maxVstay即最小化峰值缓存驻留，需考虑归一化或标准化，原累加数据直接代入可能导致适应度值变化不明显

问题二与问题一既独立又相关，问题一解的质量对问题二最优结果的质量有决定性影响，首先要保证问题一的解尽量最优。

因第一题得出最优调度序列，我们处于上帝视角，在此基础上考虑增加换入换出节点，换出哪部分缓存内容由序列的后续节点决定，优先换出后续短期内使用不到的数据缓存
```
，~~缓冲区大小是否需要加入考虑有待确定（缓冲区大的在既定目标为最小化换入换出的前提下显然优先级更低，但考虑到后续序列一直会有缓冲需求，将缓冲大的换出又潜在地减少了换出次数）~~
```
后续问题三要求时间最短，优先缓存区小的换入换出会导致时间变多，对换入换出优先级有抵抗作用，因此不把缓存区大小纳入考虑


问题3无法避免的变成多目标优化，采用基于帕累托前沿的多目标遗传算法（MOGA），其中最著名和应用最广泛的是NSGA-II。

问题三抛开问题一的结果，在问题二的背景下，直接对有效调度重新用遗传算法优化，适应度评估部分更改为多目标，每个调度序列在评估前需要用问题二的思路加入换入换出操作，最终适应度呈现为二维向量，即(总执行时间，总额外搬运也就是换入换出)


由json数据表读取所有节点数据，并作存储，节点分为操作节点、缓存申请节点、缓存释放节点三种，

- 操作节点属性包括

Id：节点的唯一整数标识符。

Op：操作指令名，如 COPY_IN, ADD, MMAD 等。

Pipe：指定该操作在哪个硬件执行单元上运行，如 Cube, Vector, MTE1 等。

Cycles：操作在该执行单元上运行所需的时钟周期数。

Bufs：操作所需输入和输出数据缓冲区的唯一标识符 BufId 列表。

古gk 